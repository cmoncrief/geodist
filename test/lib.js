/* generated by Buddy 3.0.0-beta-6 */

(function(root) {
	/**
	 * Load or retrieve cached version of requested module with id 'path' or 'path/index'
	 * @param {String} path
	 * @returns {Object}
	 */
	function require (path) {
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];

		if (!m) {
			// Handle versioned modules when called without version number
			var p, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('#')) != -1) {
					if (path == p.slice(0, idx)) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw new Error("Couldn't find module for: " + path);
		}

		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				// 'm' is key to raw source
				m = require.modules[path] = new Function('require', 'module', 'exports', require.modules[m]);
			}
			m.exports = {};
			m.filename = path;
			m.call(null, require, m, m.exports);
		}

		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	/**
	 * Retrieve raw 'lazy' module source
	 * @param {String} path
	 * @returns {String}
	 */
	require.raw = function requireRaw (path) {
		return require.modules['raw:' + path] || '';
	};

	/**
	 * Register a module with id of 'path' and callback of 'fn'
	 * Alternatively accepts 'fn' string for lazy evaluation
	 * @param {String} path
	 * @param {Function|String} fn [signature should be of type (require, module, exports)]
	 */
	require.register = function requireRegister (path, fn) {
		if ('string' == typeof fn) {
			// Store raw source
			var key = 'raw:' + path;
			require.modules[key] = fn;
			require.modules[path] = key;
		} else {
			require.modules[path] = fn;
		}
	};

	// Expose
	root.require = require;

})((typeof window !== 'undefined') ? window : global);
require.register('@yr/number-utils/index.js#0.2.2', function(require, module, exports) {
    exports.TWO_PI = (function() {
    	return Math.PI * 2;
    })();
    
    exports.HALF_PI = (function() {
    	return Math.PI * 0.5;
    })();
    
    /**
     * Converts a given value in degrees to radians
     * @param {Number} deg
     * @returns {Number}
     */
    exports.degreesToRadians = function(deg) {
    	return (deg * Math.PI) / 180;
    };
    
    /**
     * Converts a given value in radians to degrees
     * @param {Number} rad
     * @returns {Number}
     */
    exports.radiansToDegrees = function(rad) {
    	return (180 * rad) / Math.PI;
    };
    
    /**
     * Takes a 'value' within a given range and converts it to a number between 0 and 1.
     * @param {Number} value
     * @param {Number} minimum
     * @param {Number} maximum
     * @returns {Number}
     */
    var normalize = exports.normalize = function(value, min, max) {
    	if (min === max) {
    		return 1;
    	} else {
    		return (value - min) / (max - min);
    	}
    };
    
    /**
     * Takes a normalized value and a range and returns the actual value in that range.
     * @param {Number} normValue
     * @param {Number} minimum
     * @param {Number} maximum
     * @returns {Number}
     */
    var interpolate = exports.interpolate = function(normValue, min, max) {
    	return min + (max - min) * normValue;
    };
    
    /**
     * Takes a value in a given range (min1, max1) and finds the corresonding value in the next range (min2, max2).
     * @param {Number} value
     * @param {Number} min1
     * @param {Number} max1
     * @param {Number} min2
     * @param {Number} max2
     * @returns {Number}
     */
    var map = exports.map = function(value, min1, max1, min2, max2) {
    	return interpolate(normalize(value, min1, max1), min2, max2);
    };
    
    /**
     * Takes a value and limits it to fall within a given range.
     * @param {Number} value
     * @param {Number} minimum
     * @param {Number} maximum
     * @returns {Number}
     */
    var limit = exports.limit = function(value, min, max) {
    	return Math.min(Math.max(min, value), max);
    };
    
    /**
     * Generates a random number between a given range.
     * @param {Number} min
     * @param {Number} max
     * @returns {Number}
     */
    var rangedRandom = exports.rangedRandom = function(min, max) {
    	return map(Math.random(), 0, 1, min, max);
    };
    
    /**
     * Rounds a value to the number of specified decimal places
     * @param {Number} value
     * @param {Number} decimalPlaces
     * @returns {Number}
     */
    exports.round = function (value, decimalPlaces) {
    	var parts = value.toString().split('.');
    
    	// Skip if integer
    	if (parts.length == 1) {
    		return value;
    	} else {
    		var pre = parts[0] + parts[1].substr(0, decimalPlaces)
    			, post = parts[1].slice(decimalPlaces)
    			, postRound = Math.round(post/Math.pow(10, (post.length)))
    			, places = Math.pow(10, (decimalPlaces || 0));
    
    		return (parts[1].length <= decimalPlaces) ? value : (+pre + postRound) / places;
    	}
    };
});
require.register('index.js', function(require, module, exports) {
    'use strict';
    
    var numberUtils = require('@yr/number-utils/index.js#0.2.2'),
        RADIUS_UNITS = {
    	'feet': 20908800,
    	'yards': 6969600,
    	'miles': 3960,
    	'mi': 3960,
    	'kilometers': 6371,
    	'km': 6371,
    	'meters': 6371000,
    	'm': 6371000
    },
        DEFAULT_UNIT = 'meters';
    
    module.exports = getDistance;
    
    /**
     * Retrieve geographic distance between 'start' and 'end' lat/lon points
     * Options:
     *  - {Boolean} exact: return floating point value (default false)
     *  - {Boolean} format: return value + unit as string (default false)
     *  - {Number} limit: return boolean value if calculated distance is greater
     *  - {String} unit: return value in specified unit (default meters)
     *
     * @param {Object} start
     * @param {Object) end
     * @param {Object) options
     * @returns {Number}
     */
    function getDistance(start, end, options) {
    	options = options || {};
    
    	var earthRadius = getEarthRadius(options.unit),
    	    latDelta = numberUtils.degreesToRadians(end.lat - start.lat),
    	    latDeltaSin = Math.sin(latDelta * 0.5),
    	    lonDelta = numberUtils.degreesToRadians(end.lon - start.lon),
    	    lonDeltaSin = Math.sin(lonDelta * 0.5),
    	    startLatRad = numberUtils.degreesToRadians(start.lat),
    	    endLatRad = numberUtils.degreesToRadians(end.lat);
    
    	var a = latDeltaSin * latDeltaSin + lonDeltaSin * lonDeltaSin * Math.cos(startLatRad) * Math.cos(endLatRad),
    	    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    	    dist = earthRadius * c;
    
    	if (!options.exact) dist = Math.floor(dist);
    	if (options.limit) return options.limit > dist ? true : false;
    	if (options.format) dist = '' + dist + ' ' + (options.unit || DEFAULT_UNIT);
    
    	return dist;
    }
    
    /**
     * Retrieve radius of earth in specified 'unit'
     * @param {String} unit
     * @returns {Number}
     */
    function getEarthRadius(unit) {
    	unit = unit || DEFAULT_UNIT;
    	unit = unit.toLowerCase();
    	if (!RADIUS_UNITS[unit]) unit = DEFAULT_UNIT;
    
    	return RADIUS_UNITS[unit];
    }
});
require('index.js');